"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.runTests = exports.exec = void 0;

const tslib_1 = require("tslib");

const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const ora_1 = (0, tslib_1.__importDefault)(require("ora"));

const runtime_1 = require("../common/runtime");

const testCollector_1 = require("../common/testCollector");

const reader_1 = require("../core/reader");

const summary_1 = require("../core/summary");

const testExecutor_1 = require("../core/testExecutor");

const logUpdate_1 = require("../utils/logUpdate");

const validate_1 = require("./validate");

const tsRegister_1 = (0, tslib_1.__importDefault)(require("../core/tsRegister"));

const debug_1 = require("../common/debug");

const consts_1 = require("../consts");

process.on("uncaughtException", () => {
  stopLoading();
});
let spinner;

async function exec(options) {
  if (options.config) {
    runtime_1.runtime.configFilePath = options.config;
  }

  (0, tsRegister_1.default)(consts_1.DEFAULT_CONFIG.project);
  (0, debug_1.debug)("runtime.project: ", runtime_1.runtime.project);
  (0, debug_1.debug)("runtime.configFilePath: " + runtime_1.runtime.configFilePath);
  await loadConfigs();

  if (options.files) {
    runtime_1.runtime.setConfigs(
      {
        testMatches: options.files.split(" "),
      },
      true,
    );
  }

  if (runtime_1.runtime.project) {
    (0, tsRegister_1.default)(runtime_1.runtime.configs);
  }

  (0, debug_1.debug)("loaded configs: ", runtime_1.runtime.configs);
  await (0, validate_1.validate)(runtime_1.runtime.configs);
  await runTests();
}

exports.exec = exec;

async function loadConfigs() {
  const configs = reader_1.reader.loadConfig();
  runtime_1.runtime.setConfigs(configs, true);
}

async function runTests() {
  startLoading("login to corde bot");

  try {
    const loginPromise = runtime_1.runtime.loginBot(runtime_1.runtime.cordeBotToken);
    const readyPromise = runtime_1.runtime.events.onceReady();
    await Promise.allSettled([loginPromise, readyPromise]);
    spinner.stop();
    const testMatches = await reader_1.reader.getTestsFromFiles({
      filesPattern: runtime_1.runtime.testMatches,
      ignorePattern: runtime_1.runtime.modulePathIgnorePatterns,
    });

    if (testMatches.length === 0) {
      console.log(
        `${chalk_1.default.bgYellow(chalk_1.default.black(" INFO "))} No test were found.`,
      );
      await finishProcess(0);
    }

    const log = new logUpdate_1.LogUpdate();
    const testRunner = new testExecutor_1.TestExecutor(log);
    const executionReport = await testRunner.runTestsAndPrint(testMatches);

    if (runtime_1.runtime.environment.isE2eTest) {
      console.log(log.stdout);
    }

    summary_1.summary.print(executionReport);

    if (executionReport.totalTestsFailed > 0) {
      await finishProcess(1);
    } else {
      await finishProcess(0);
    }
  } catch (error) {
    spinner.stop();
    console.error(error);
    await finishProcess(1);
  }
}

exports.runTests = runTests;

async function finishProcess(code, error) {
  try {
    if (error) {
      console.log(error);
    }

    if (testCollector_1.testCollector.afterAllFunctions.hasFunctions) {
      const exceptions =
        await testCollector_1.testCollector.afterAllFunctions.executeWithCatchCollectAsync();

      if (exceptions.length) {
        console.log(...exceptions);
        code = 1;
      }
    }

    runtime_1.runtime.logoffBot();
  } finally {
    process.exit(code);
  }
}

function startLoading(initialMessage) {
  spinner = (0, ora_1.default)(initialMessage).start();
  spinner._spinner = {
    interval: 80,
    frames: ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"],
  };
  spinner.color = getRandomSpinnerColor();
}

function getRandomSpinnerColor() {
  const colors = ["red", "green", "yellow", "blue", "magenta", "cyan"];
  let random = Math.random() * (colors.length - 1);
  random = Math.round(random);
  return colors[random];
}

function stopLoading() {
  if (spinner) {
    spinner.stop();
    spinner.clear();
  }
}
